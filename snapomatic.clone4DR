#! /usr/bin/python3

import sys
pythonversion=sys.version_info
if pythonversion[0] != 3 or (pythonversion[1] < 6 or pythonversion[1] > 11):
    print("This script requires Python 3.6 through 3.11")
    sys.exit(1)
sys.path.append(sys.path[0] + "/NTAPlib")
import userio
from getSnapmirror import getSnapmirror
from getSnapshots import getSnapshots
from getLUNs import getLUNs
from cloneVolumes import cloneVolumes
from mapLUNs import mapLUNs
import time
import getopt

snapomaticversion='DEV'

validoptions={'target':'multistr',
              'dbfsuffix':'str',
              'logsuffix':'str',
              'igrouptoken':'int',
              'prefix':'str',
              'igroupname':'str',
              'split':'bool',
              'nosleep':'bool',
              'debug':'bool',
              'restdebug':'bool',
              'recoverypoint':'timestamp'}

requiredoptions=['target','dbfsuffix','logsuffix','igrouptoken','prefix']

usage="Version " + snapomaticversion + "\n" + \
      "clone4DR --target\n" + \
      "          (name of target svm and volumes)\n" + \
      "          (syntax: svm:volume, wildcards accepted)\n\n" + \
      "          --dbfsuffix\n" + \
      "          (suffix that identifies datafile volumes)\n\n" + \
      "          --logsuffix\n" + \
      "          (suffix that identifies log volumes)\n\n" + \
      "          --igrouptoken\n" + \
      "          (identifies the _ delimited position of the igroup)\n\n" + \
      "          --online-backup-prefix\n" + \
      "          (identifies the string used to identify the online backup datafile snapshot)\n\n" + \
      "          --recoverypoint\n" + \
      "          (recovery timestamp in YYYY-MM-DDTHH:MM:SS+ZZZZ)\n\n" + \
      "          [--igroupname]\n" + \
      "          (optionally specifies the igroup name, %=token\n\n" + \
      "          [--split]\n" + \
      "          (split the cloned volumes)\n\n" + \
      "          [--debug]\n" + \
      "          (show debug output)\n\n" + \
      "          [--restdebug]\n" + \
      "          (show REST API calls and responses)\n\n" 

myopts=userio.validateoptions(sys.argv,validoptions,usage=usage,required=requiredoptions)

svm=myopts.target[0]
if len(myopts.target) == 1:
    volumes='*'
else:
    volumes=myopts.target[1:]

dbfpattern=myopts.dbfsuffix
if not dbfpattern[1] == '_':
    dbfpattern='_' + dbfpattern
logpattern=myopts.logsuffix
if not logpattern[1] == '_':
    logpattern='_' + logpattern
igrouptoken=myopts.igrouptoken

try:
    recoverytarget=myopts.recoverypoint
except:
    recoverytarget=False

prefix=myopts.prefix

splitclones=myopts.split

debug=0
if myopts.debug:
    debug=debug+1

if myopts.restdebug:
    debug=debug+2

igroupname=myopts.igroupname

nosleep=myopts.nosleep

snapmirror=getSnapmirror(svm,volumes=volumes,debug=debug)
if not snapmirror.go():
    snapmirror.showDebug()
if len(snapmirror.snapmirrorDestinations.keys()) < 1:
    userio.fail("No matching snapmirrored volumes detected")

clonelist=[]
for volume in snapmirror.snapmirrorDestinations[svm]['volumes'].keys():
    print(">> " + volume)
    clonelist.append(volume)
print()

print("Building datafile/log volume sets...")
volpairs={}
for volume in clonelist:
    if volume[-len(dbfpattern):] == dbfpattern or volume[-len(logpattern):] == logpattern:
        key=volume.rsplit('_',1)[0]
        if key in volpairs.keys():
            volpairs[key].append(volume)
        else:
            volpairs[key]=[volume]

for key in volpairs.keys():
    if len(volpairs[key]) < 2:
        print("Unable to find both " + dbfpattern + " and " + logpattern + " volume for " + key)
        sys.exit(1)
    elif len(volpairs[key]) > 2:
        print("Multiple datasets match volume pattern " + key)
        sys.exit(1)
print("Identified " + str(len(volpairs)) + " dataset pairs")
for pair in volpairs:
    print(">> " + pair)
print()

print("Retrieving snapshots...")
print("...")
snapshots=getSnapshots(svm,volumes=clonelist,debug=debug)
if not snapshots.go():
    snapshots.debug()

for vol in clonelist:
    if vol in snapshots.snapshots.keys():
        print("Most recent snapshot on volume " + vol + ":")
        print(">> " + snapshots.snapshots[vol]['recent'])
    else:
        print("No matching snapshots found on volume " + vol)
    print()

clonetargets=[]
print("Verifying datafile snapshot state is earlier than log snapshot state...")
print("...")
for key in volpairs.keys():
    recentdbf=None
    for snap,date in snapshots.snapshots[key + dbfpattern]['ordered']:
        if snap[:len(prefix)] + '_' == prefix + "_":
            recentdbf=snap
    if recentdbf is None:
        userio.warn("No matching online backup snapshots for " + key + dbfpattern)
    else:
        if not recoverytarget:
            recentlog=snapshots.snapshots[key + logpattern]['recent']
            print(key + logpattern + \
                  " most recent snapshot is " + \
                  snapshots.snapshots[key + logpattern]['snapshots'][recentlog]['date'])
            logtime=snapshots.snapshots[key + logpattern]['snapshots'][recentlog]['epoch']
        else:
            logtime=False
            for x in range(0,len(snapshots.snapshots[key + logpattern]['ordered'])-1):
                if snapshots.snapshots[key + logpattern]['ordered'][x][1] > recoverytarget \
                   and snapshots.snapshots[key + logpattern]['ordered'][x+1][1] < recoverytarget:
                        logtime=snapshots.snapshots[key + logpattern]['snapshots'][snapshots.snapshots[key + logpattern]['ordered'][x][0]]['epoch']
                        recentlog=snapshots.snapshots[key + logpattern]['ordered'][x][0]
                        break
            if logtime:
                print("Most recent log snapshot meeting recovery target is " + recentlog + " with timestamp " + snapshots.snapshots[key + logpattern]['snapshots'][recentlog]['date'])
    
        dbftime=snapshots.snapshots[key + dbfpattern]['snapshots'][recentdbf]['epoch']
    
        print(key + dbfpattern + \
                    " most recent snapshot is " + \
                    snapshots.snapshots[key + dbfpattern]['snapshots'][recentdbf]['date'])
    
        if not logtime > dbftime:
            print("Datafile state is later than log state, obtaining prior snapshot")
            foundit=False
            for snapshot,recoverypoint in snapshots.snapshots[key + dbfpattern]['ordered']:
                if recoverypoint < logtime:
                    print("Found snapshot " + snapshot + " with recoverypoint " + \
                           snapshots.snapshots[key + dbfpattern]['snapshots'][snapshot]['date'])
                    clonetargets.append((key + dbfpattern,snapshots.snapshots[key+dbfpattern]['snapshots'][snapshot]['uuid']))
                    clonetargets.append((key + logpattern,snapshots.snapshots[key+logpattern]['snapshots'][recentlog]['uuid']))
                    foundit=True
                    print(">> Datafile/log set for " + key + " PASSED")
                    print()
                    break
            if not foundit:
                print("Unable to find snapshot pair for database " + key)
        else:
            print(">> Datafile/log set for " + key + " PASSED")
            print()
            clonetargets.append((key + dbfpattern,snapshots.snapshots[key+dbfpattern]['snapshots'][recentdbf]['uuid']))
            clonetargets.append((key + logpattern,snapshots.snapshots[key+logpattern]['snapshots'][recentlog]['uuid']))

clonecompleted=[]
clonefailed=[]
print("Cloning volumes...")
print("...")
for vol,snapshot in clonetargets:
    clone=cloneVolumes(svm,(vol,"failover_"+ vol,snapshot),uuid=True,split=splitclones,debug=debug)
    if not clone.go():
        clone.showDebug()
        clonefailed.append(vol)
    else:
        clonecompleted.append(vol + "failover_")
print()

if not nosleep:
    print("Sleeping 10 seconds for LUN registration to complete")
    time.sleep(10)
    print()

print("Retrieving LUNs from cloned volumes...")
print("...")
for volume in volumes:
    clonedluns=getLUNs(svm,name="/vol/failover_" + volume,debug=debug)
    if not clonedluns.go():
        print("Unable to retrieve LUN list")
        clonedluns.showDebug()
        sys.exit(1)

    for lun in clonedluns.luns.keys():
        igroupbase=lun.split('_')[igrouptoken]
        if igroupname:
            igroup=igroupname.replace('%',igroupbase)
        else:
            igroup=igroupbase
        print("Mapping " + lun + " to igroup " + igroup)
        mapping=mapLUNs(svm,lun,igroup,debug=debug)
        if not mapping.go():
            mapping.showDebug()

print()
